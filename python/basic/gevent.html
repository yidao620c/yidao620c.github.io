<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://lib.baomitu.com/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yidao620c.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一般将coroutine称之为协程（或微线程，也有称纤程的）。 我在python并发编程那篇文章已经详细讲解了进程Process和线程Thread的用法， 很早就想再写一篇专门讲解coroutine以及相关的优秀库gevent。 目前常见的coroutine应用都是网络程序中，所以我们先来看看各种不同的网络框架模型， 然后再介绍coroutine就会比较理解了。">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈coroutine和gevent">
<meta property="og:url" content="http://yidao620c.github.io/python/basic/gevent.html">
<meta property="og:site_name" content="飞污熊博客">
<meta property="og:description" content="一般将coroutine称之为协程（或微线程，也有称纤程的）。 我在python并发编程那篇文章已经详细讲解了进程Process和线程Thread的用法， 很早就想再写一篇专门讲解coroutine以及相关的优秀库gevent。 目前常见的coroutine应用都是网络程序中，所以我们先来看看各种不同的网络框架模型， 然后再介绍coroutine就会比较理解了。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-01-02T00:16:18.000Z">
<meta property="article:modified_time" content="2023-07-29T22:51:06.962Z">
<meta property="article:author" content="Xiong Neng">
<meta property="article:tag" content="python">
<meta property="article:tag" content="gevent">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yidao620c.github.io/python/basic/gevent.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yidao620c.github.io/python/basic/gevent.html","path":"python/basic/gevent.html","title":"浅谈coroutine和gevent"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>浅谈coroutine和gevent | 飞污熊博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">飞污熊博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">静下心来做一件事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">不同网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8F%E5%8D%95%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">阻塞式单进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8F%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">阻塞式多进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="nav-number">1.3.</span> <span class="nav-text">非阻塞式事件驱动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FCoroutine"><span class="nav-number">1.4.</span> <span class="nav-text">非阻塞式Coroutine</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Coroutine"><span class="nav-number">2.</span> <span class="nav-text">Coroutine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gevent"><span class="nav-number">3.</span> <span class="nav-text">Gevent</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">3.1.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90greenlet"><span class="nav-number">3.2.</span> <span class="nav-text">生成greenlet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Greenlet-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">3.3.</span> <span class="nav-text">Greenlet 的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.4.</span> <span class="nav-text">终止程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6"><span class="nav-number">3.5.</span> <span class="nav-text">超时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81"><span class="nav-number">3.6.</span> <span class="nav-text">猴子补丁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">3.7.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">3.8.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%92%8C%E6%B1%A0"><span class="nav-number">3.9.</span> <span class="nav-text">组和池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.10.</span> <span class="nav-text">锁和信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.11.</span> <span class="nav-text">子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#actor%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.12.</span> <span class="nav-text">actor模型</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xiong Neng"
      src="/images/my.png">
  <p class="site-author-name" itemprop="name">Xiong Neng</p>
  <div class="site-description" itemprop="description">这里要写啥我不是很清楚 →_→</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">283</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yidao620c" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yidao620c" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yidao620@gmail.com" title="E-Mail → mailto:yidao620@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yidao620c.github.io/python/basic/gevent.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my.png">
      <meta itemprop="name" content="Xiong Neng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞污熊博客">
      <meta itemprop="description" content="这里要写啥我不是很清楚 →_→">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="浅谈coroutine和gevent | 飞污熊博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          浅谈coroutine和gevent
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-01-02 08:16:18" itemprop="dateCreated datePublished" datetime="2016-01-02T08:16:18+08:00">2016-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>一般将coroutine称之为协程（或微线程，也有称纤程的）。
我在python并发编程那篇文章已经详细讲解了进程Process和线程Thread的用法，
很早就想再写一篇专门讲解coroutine以及相关的优秀库gevent。</p>
<p>目前常见的coroutine应用都是网络程序中，所以我们先来看看各种不同的网络框架模型，
然后再介绍coroutine就会比较理解了。</p>
<span id="more"></span>

<h2 id="不同网络模型"><a href="#不同网络模型" class="headerlink" title="不同网络模型"></a>不同网络模型</h2><h3 id="阻塞式单进程"><a href="#阻塞式单进程" class="headerlink" title="阻塞式单进程"></a>阻塞式单进程</h3><p>这样的网络程序最简单，一个进程一个循环处理网络请求，当然性能也是最差的。
现在服务器采用这种模型的基本看不到了。</p>
<h3 id="阻塞式多进程"><a href="#阻塞式多进程" class="headerlink" title="阻塞式多进程"></a>阻塞式多进程</h3><p>每个请求开一个进程去处理，这样就能同时处理多个请求了，
不过缺点就是当请求数变大时CPU花在进程切换开销巨大，效率低下。</p>
<h3 id="非阻塞式事件驱动"><a href="#非阻塞式事件驱动" class="headerlink" title="非阻塞式事件驱动"></a>非阻塞式事件驱动</h3><p>也是多进程，不过使用一个主进程循环来检查是否有网络I&#x2F;O事件发生，再来决定怎样处理。
省去了上下文切换、进程复制等成本，也不会有死锁、竞争的发生。
不过缺点是没有阻塞式进程直观，<a target="_blank" rel="noopener" href="https://twistedmatrix.com/trac/">Twisted</a>就是这样的网络框架。</p>
<h3 id="非阻塞式Coroutine"><a href="#非阻塞式Coroutine" class="headerlink" title="非阻塞式Coroutine"></a>非阻塞式Coroutine</h3><p>有没有可能既有事件驱动的好处，又有阻塞式编程的直观的模型呢？答案也行就是我要讲的coroutine了。
基本上它的本质也是事件驱动，只在单一循环上面检查事件的发生，但是加上了coroutine的概念。
<a target="_blank" rel="noopener" href="http://www.gevent.org/">gevent</a>就是这种框架的代表。</p>
<h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><p>简单来讲，coroutine就是允许你暂时中断之后再继续执行的程序。事实上，python最基础的coroutine就是生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 暂时返回一个值，并将控制权交出去</span></span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">u&#x27;foo: 控制权又回到我手上了，叫我大笨蛋&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bar = foo()</span><br><span class="line"><span class="comment"># 执行coroutine</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(bar))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&#x27;main: 现在控制权在我手上，啦啦啦&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main:hello baby!&#x27;</span>)</span><br><span class="line"><span class="comment"># 回到刚刚foo这个coroutine中断的地方继续执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(bar))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&#x27;main: 老大我又来了&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(bar))</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">main: 现在控制权在我手上，啦啦啦</span><br><span class="line">main:hello baby!</span><br><span class="line">foo: 控制权又回到我手上了，叫我大笨蛋</span><br><span class="line">1</span><br><span class="line">main: 老大我又来了</span><br><span class="line">foo: 控制权又回到我手上了，叫我大笨蛋</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>看到没有，我们的foo在执行过程中被中断又继续了好几回。
你刚开始可能觉得这样做没什么好处呀，thread的上下文切换不是也可以暂停再继续么。
其实重点在于：</p>
<ul>
<li>thread之间需要context-switch，而且成本很高，但coroutine没有任何上下文切换</li>
<li>可轻松生成大量的coroutine，基本没什么开销</li>
<li>所有的coroutine全部都在一个线程中完成</li>
<li>thread的切换基本靠OS来觉得该执行哪个，而coroutine是自己控制。</li>
</ul>
<h2 id="Gevent"><a href="#Gevent" class="headerlink" title="Gevent"></a>Gevent</h2><p>优秀的第三方库gevent就是基于coroutine的Python网络库，
它用到Greenlet提供的，封装了libevent事件循环的高层同步API，它的coroutine是由Greenlet负责生成的。</p>
<p>事实上程序写的跟普通的阻塞式程序一样，但它千真万确是异步的，这是它神奇的地方，我们来看实际的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Spawn multiple workers and wait for them to complete&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">urls = [<span class="string">&#x27;http://www.gevent.org/&#x27;</span>, <span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="string">&#x27;http://www.python.org&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="comment"># patches stdlib (including socket and ssl modules) to cooperate with other greenlets</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_head</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="built_in">print</span>（<span class="string">&#x27;Starting %s&#x27;</span> % url）</span><br><span class="line">    data = urllib2.urlopen(url).read()</span><br><span class="line">    <span class="built_in">print</span>（<span class="string">&#x27;%s: %s bytes: %r&#x27;</span> % (url, <span class="built_in">len</span>(data), data[:<span class="number">50</span>])）</span><br><span class="line"></span><br><span class="line">    jobs = [gevent.spawn(print_head, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line">    gevent.joinall(jobs)</span><br></pre></td></tr></table></figure>

<p>写起来非常简单，不过里面有一句<code>monkey.patch_all()</code>会让人有点疑惑。
也就是猴子补丁，因为python内置的各种函数库和IO库一般都是阻塞式的，比如<code>sleep()</code>就会当前进程，
而monkey就是负责将这些阻塞函数全部取代替换成gevent中相应的异步函数。</p>
<p>gevent打了monkey patch之后会设置python相应的模块设置成非阻塞，
然后在内部实现epoll的机制，一旦调用非阻塞的IO(比如recv)都会立刻返回，
并且设置一个回调函数，这个回调函数用于切换到当前子coroutine，
设置好回掉函数之后就把控制权返回给主coroutine，主coroutine继续调度。
一旦网络I&#x2F;O准备就绪，epoll会触发之前设置的回调函数，从而引发主coroutine切换到子coroutine，做相应的操作。</p>
<p><code>joinall()</code>的意思是等待列表中所有coroutine完成后再返回。</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>gevent里面的上下文切换是非常平滑的。在下面的例子程序中，我们可以看到两个上下文通过调用 gevent.sleep()来互相切换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Running in foo&#x27;</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Explicit context switch to foo again&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Explicit context to bar&#x27;</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Implicit context switch back to bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(foo),</span><br><span class="line">    gevent.spawn(bar),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>接下来一个例子中可以看到gevent是安排各个任务的执行的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">pid</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Some non-deterministic task</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    gevent.sleep(random.randint(<span class="number">0</span>, <span class="number">2</span>) * <span class="number">0.001</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task&#x27;</span>, pid, <span class="string">&#x27;done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">synchronous</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        task(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">asynchronous</span>():</span><br><span class="line">    threads = [gevent.spawn(task, i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>)]</span><br><span class="line">    gevent.joinall(threads)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Synchronous:&#x27;</span>)</span><br><span class="line">synchronous()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Asynchronous:&#x27;</span>)</span><br><span class="line">asynchronous()</span><br></pre></td></tr></table></figure>

<p>在同步的情况下，任务是按顺序执行的，在执行各个任务的时候会阻塞主线程。</p>
<p>而 <code>gevent.spawn</code> 的重要功能就是封装了greenlet里面的函数。
初始化的greenlet放在了threads这个list里面，
被传递给了 <code>gevent.joinall</code> 这个函数，它会阻塞当前的程序来执行所有的greenlet。</p>
<p>在异步执行的情况下，所有任务的执行顺序是完全随机的。每一个greenlet的都不会阻塞其他greenlet的执行。</p>
<h3 id="生成greenlet"><a href="#生成greenlet" class="headerlink" title="生成greenlet"></a>生成greenlet</h3><p>上面我们通过<code>gevent.spawn</code>来包装了对于greenlet的生成，
另外我们还能可以通过创建Greenlet的子类，并且重写 _run 方法来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyGreenlet</span>(<span class="title class_ inherited__">Greenlet</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, message, n</span>):</span><br><span class="line">        Greenlet.__init__(self)</span><br><span class="line">        self.message = message</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.message)</span><br><span class="line">        gevent.sleep(self.n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = MyGreenlet(<span class="string">&quot;Hi there!&quot;</span>, <span class="number">3</span>)</span><br><span class="line">g.start()</span><br><span class="line">g.join()</span><br></pre></td></tr></table></figure>

<h3 id="Greenlet-的状态"><a href="#Greenlet-的状态" class="headerlink" title="Greenlet 的状态"></a>Greenlet 的状态</h3><p>greenlet在执行的时候也会出错。Greenlet有可能会无法抛出异常，停止失败，或者消耗了太多的系统资源。</p>
<p>greenlet的内部状态通常是一个依赖时间的参数。greenlet有一些标记来让你能够监控greenlet的状态</p>
<ul>
<li>started – 标志greenlet是否已经启动</li>
<li>ready – 标志greenlet是否已经被终止</li>
<li>successful() – 标志greenlet是否已经被终止，并且没有抛出异常</li>
<li>value – 由greenlet返回的值</li>
<li>exception – 在greenlet里面没有被捕获的异常</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">win</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;You win!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fail</span>():</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;You fail at failing.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">winner = gevent.spawn(win)</span><br><span class="line">loser = gevent.spawn(fail)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(winner.started)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(loser.started)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Exceptions raised in the Greenlet, stay inside the Greenlet.</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gevent.joinall([winner, loser])</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;This will never be reached&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(winner.value)  <span class="comment"># &#x27;You win!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(loser.value)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(winner.ready())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(loser.ready())  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(winner.successful())  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(loser.successful())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The exception raised in fail, will not propogate outside the</span></span><br><span class="line"><span class="comment"># greenlet. A stack trace will be printed to stdout but it</span></span><br><span class="line"><span class="comment"># will not unwind the stack of the parent.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(loser.exception)</span><br></pre></td></tr></table></figure>

<h3 id="终止程序"><a href="#终止程序" class="headerlink" title="终止程序"></a>终止程序</h3><p>在主程序收到一个SIGQUIT 之后会阻塞程序的执行让Greenlet无法继续执行。
这会导致僵尸进程的产生，需要在操作系统中将这些僵尸进程清除掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_forever</span>():</span><br><span class="line">    gevent.sleep(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gevent.signal(signal.SIGQUIT, gevent.shutdown)</span><br><span class="line">    thread = gevent.spawn(run_forever)</span><br><span class="line">    thread.join()</span><br></pre></td></tr></table></figure>

<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>在gevent中支持对于coroutine的超时控制，还能使用<code>with</code>上下文，示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout</span><br><span class="line"></span><br><span class="line">time_to_wait = <span class="number">5</span>  <span class="comment"># seconds</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TooLong</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Timeout(time_to_wait, TooLong):</span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h3><p>现在这是gevent里面的一个难点。下面一个例子里可能看到 &#96;monkey.patch_socket()&#96;&#96; 能够在运行时里面修改基础库socket：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(socket.socket)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span></span><br><span class="line"><span class="string">&quot;After monkey patch&quot;</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_socket()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(socket.socket)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(select.select)</span><br><span class="line">monkey.patch_select()</span><br><span class="line"><span class="built_in">print</span></span><br><span class="line"><span class="string">&quot;After monkey patch&quot;</span></span><br><span class="line"><span class="built_in">print</span>(select.select)</span><br></pre></td></tr></table></figure>

<p>Python的运行时里面允许能够大部分的对象都是可以修改的，包括模块，类和方法。这通常是一个坏主意，
然而在极端的情况下，当有一个库需要加入一些Python基本的功能的时候，monkey patch就能派上用场了。
在上面的例子里，gevent能够改变基础库里的一些使用IO阻塞模型的库比如socket，ssl，threading等等并且把它们改成协程的执行方式。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>有时候我们还需要在多个greenlet直接进行通信，比如某些操作的同步。事件(event)是一个在Greenlet之间异步通信的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.event <span class="keyword">import</span> Event</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Illustrates the use of events</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">evt = Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setter</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;After 3 seconds, wake all threads waiting on the value of evt&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A: Hey wait for me, I have to do something&#x27;</span>)</span><br><span class="line">    gevent.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Ok, I&#x27;m done&quot;</span>)</span><br><span class="line">    evt.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">waiter</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;After 3 seconds the get call will unblock&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;ll wait for you&quot;</span>)</span><br><span class="line">    evt.wait()  <span class="comment"># blocking</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s about time&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    gevent.joinall([</span><br><span class="line">        gevent.spawn(setter),</span><br><span class="line">        gevent.spawn(waiter),</span><br><span class="line">        gevent.spawn(waiter),</span><br><span class="line">        gevent.spawn(waiter),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>事件对象的一个扩展是AsyncResult，它允许你在唤醒调用上附加一个值。
它有时也被称作是future或defered，因为它持有一个指向将来任意时间可设置为任何值的引用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.event <span class="keyword">import</span> AsyncResult</span><br><span class="line"></span><br><span class="line">a = AsyncResult()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setter</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    After 3 seconds set the result of a.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    gevent.sleep(<span class="number">3</span>)</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="string">&#x27;Hello!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">waiter</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    After 3 seconds the get call will unblock after the setter</span></span><br><span class="line"><span class="string">    puts a value into the AsyncResult.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(a.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(setter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一个排序的数据集合，它有常见的put &#x2F; get操作，但是它是以在Greenlet之间可以安全操作的方式来实现的。</p>
<p>举例来说，如果一个Greenlet从队列中取出一项，此项就不会被同时执行的其它Greenlet再取到了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">tasks = Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> tasks.empty():</span><br><span class="line">        task = tasks.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Worker %s got task %s&#x27;</span> % (n, task))</span><br><span class="line">        gevent.sleep(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Quitting time!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">boss</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">25</span>):</span><br><span class="line">        tasks.put_nowait(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gevent.spawn(boss).join()</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(worker, <span class="string">&#x27;steve&#x27;</span>),</span><br><span class="line">    gevent.spawn(worker, <span class="string">&#x27;john&#x27;</span>),</span><br><span class="line">    gevent.spawn(worker, <span class="string">&#x27;nancy&#x27;</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>如果需要，队列也可以阻塞在put或get操作上。</p>
<p>put和get操作都有非阻塞的版本，put_nowait和get_nowait不会阻塞，
然而在操作不能完成时抛出<code>gevent.queue.Empty</code>或<code>gevent.queue.Full</code>异常。</p>
<p>我们让boss与多个worker同时运行，并限制了queue不能放入多于3个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue, Empty</span><br><span class="line"></span><br><span class="line">tasks = Queue(maxsize=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            task = tasks.get(timeout=<span class="number">1</span>)  <span class="comment"># decrements queue size by 1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Worker %s got task %s&#x27;</span> % (n, task))</span><br><span class="line">            gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">except</span> Empty:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Quitting time!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">boss</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Boss will wait to hand out work until a individual worker is</span></span><br><span class="line"><span class="string">    free since the maxsize of the task queue is 3.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        tasks.put(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Assigned all work in iteration 1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>, <span class="number">20</span>):</span><br><span class="line">        tasks.put(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Assigned all work in iteration 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(boss),</span><br><span class="line">    gevent.spawn(worker, <span class="string">&#x27;steve&#x27;</span>),</span><br><span class="line">    gevent.spawn(worker, <span class="string">&#x27;john&#x27;</span>),</span><br><span class="line">    gevent.spawn(worker, <span class="string">&#x27;bob&#x27;</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h3 id="组和池"><a href="#组和池" class="headerlink" title="组和池"></a>组和池</h3><p>组(group)是一个运行中greenlet的集合，集合中的greenlet像一个组一样会被共同管理和调度。
它也兼饰了像Python的multiprocessing库那样的平行调度器的角色:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Group</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">talk</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(talk, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">g2 = gevent.spawn(talk, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">g3 = gevent.spawn(talk, <span class="string">&#x27;fizz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">group = Group()</span><br><span class="line">group.add(g1)</span><br><span class="line">group.add(g2)</span><br><span class="line">group.join()</span><br><span class="line"></span><br><span class="line">group.add(g3)</span><br><span class="line">group.join()</span><br></pre></td></tr></table></figure>

<p>池(pool)是一个为处理数量变化并且需要限制并发的greenlet而设计的结构。
在需要并行地做很多受限于网络和IO的任务时常常需要用到它。</p>
<p>当构造gevent驱动的服务时，经常会将围绕一个池结构的整个服务作为中心。一个例子就是在各个socket上轮询的类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SocketPool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.pool = Pool(<span class="number">1000</span>)</span><br><span class="line">        self.pool.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">listen</span>(<span class="params">self, socket</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            socket.recv()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_handler</span>(<span class="params">self, socket</span>):</span><br><span class="line">        <span class="keyword">if</span> self.pool.full():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;At maximum pool size&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.pool.spawn(self.listen, socket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shutdown</span>(<span class="params">self</span>):</span><br><span class="line">        self.pool.kill()</span><br></pre></td></tr></table></figure>

<h3 id="锁和信号量"><a href="#锁和信号量" class="headerlink" title="锁和信号量"></a>锁和信号量</h3><p>信号量是一个允许greenlet相互合作，限制并发访问或运行的低层次的同步原语。信号量有两个方法，acquire和release。
在信号量是否已经被acquire或release，和拥有资源的数量之间不同，被称为此信号量的范围 (the bound of the semaphore)。
如果一个信号量的范围已经降低到0，它会阻塞acquire操作直到另一个已经获得信号量的greenlet作出释放。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> gevent.coros <span class="keyword">import</span> BoundedSemaphore</span><br><span class="line"></span><br><span class="line">sem = BoundedSemaphore(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker1</span>(<span class="params">n</span>):</span><br><span class="line">    sem.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Worker %i acquired semaphore&#x27;</span> % n)</span><br><span class="line">    sleep(<span class="number">0</span>)</span><br><span class="line">    sem.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Worker %i released semaphore&#x27;</span> % n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker2</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Worker %i acquired semaphore&#x27;</span> % n)</span><br><span class="line">        sleep(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Worker %i released semaphore&#x27;</span> % n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = Pool()</span><br><span class="line">pool.<span class="built_in">map</span>(worker1, xrange(<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">pool.<span class="built_in">map</span>(worker2, xrange(<span class="number">3</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p>范围为1的信号量也称为锁(lock)，它向单个greenlet提供了互斥访问。信号量和锁常常用来保证资源只在程序上下文被单次使用。</p>
<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p>自gevent 1.0起，<code>gevent.subprocess</code>，一个Python subprocess模块的修补版本已经添加，它支持协作式的等待子进程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.subprocess <span class="keyword">import</span> Popen, PIPE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cron</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cron&quot;</span>)</span><br><span class="line">        gevent.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = gevent.spawn(cron)</span><br><span class="line">sub = Popen([<span class="string">&#x27;sleep 1; uname&#x27;</span>], stdout=PIPE, shell=<span class="literal">True</span>)</span><br><span class="line">out, err = sub.communicate()</span><br><span class="line">g.kill()</span><br><span class="line"><span class="built_in">print</span>(out.rstrip())</span><br></pre></td></tr></table></figure>

<h3 id="actor模型"><a href="#actor模型" class="headerlink" title="actor模型"></a>actor模型</h3><p>actor模型是一个由于Erlang变得普及的更高层的并发模型。简单的说它的主要思想就是许多个独立的Actor，
每个Actor有一个可以从其它Actor接收消息的收件箱。Actor内部的主循环遍历它收到的消息，并根据它期望的行为来采取行动。</p>
<p>Gevent没有原生的Actor类型，但在一个子类化的Greenlet内使用队列，我们可以定义一个非常简单的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span>(gevent.Greenlet):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.inbox = Queue()</span><br><span class="line">        Greenlet.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">receive</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Define in your subclass.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> <span class="literal">NotImplemented</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run</span>(<span class="params">self</span>):</span><br><span class="line">        self.running = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.running:</span><br><span class="line">            message = self.inbox.get()</span><br><span class="line">            self.receive(message)</span><br></pre></td></tr></table></figure>

<p>接下来使用这个actor的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pinger</span>(<span class="title class_ inherited__">Actor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">receive</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">        pong.inbox.put(<span class="string">&#x27;ping&#x27;</span>)</span><br><span class="line">        gevent.sleep(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ponger</span>(<span class="title class_ inherited__">Actor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">receive</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">        ping.inbox.put(<span class="string">&#x27;pong&#x27;</span>)</span><br><span class="line">        gevent.sleep(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ping = Pinger()</span><br><span class="line">pong = Ponger()</span><br><span class="line"></span><br><span class="line">ping.start()</span><br><span class="line">pong.start()</span><br><span class="line"></span><br><span class="line">ping.inbox.put(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">gevent.joinall([ping, pong])</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
              <a href="/tags/gevent/" rel="tag"># gevent</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/python/pycore/web.html" rel="prev" title="python核心 - web开发">
                  <i class="fa fa-angle-left"></i> python核心 - web开发
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/tool/basic/hexo.html" rel="next" title="使用hexo搭建github博客">
                  使用hexo搭建github博客 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">XiongNeng</span>
  </div>

    </div>
  </footer>

  

  <a href="https://github.com/yidao620c" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://lib.baomitu.com/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://lib.baomitu.com/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://lib.baomitu.com/mermaid/10.7.0/mermaid.min.js","integrity":"sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
